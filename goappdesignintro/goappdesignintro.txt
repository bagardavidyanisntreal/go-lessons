С чего начать?

Данные советы будут полезны для архитектуры не только приложений на Go. Возможно, часть советов поможет сделать выбор и
с другим инструментарием.

Я бы хотел представить некую реализацию "чистой архитектуры" (ЧА), в рамках Go проекта или Go модуля. Данный подход навеян
изучением ЧА Боб Мартина (которая изначально была направлена на работу монолитных приложений), но в рамках микросервисов
и распределения нагрузок системы.

Ещё советую интересное видео с данным подходом от коллег:
 - https://youtu.be/V6lQG6d5LgU

Самое главное правило - всегда брать то, что действительно нужно: если выбор пал на "что-то", что-угодно (технологию,
паттерн, ещё один уровень абстракции, разделение, и прочее, прочее, прочее), то стоит задать несколько простых вопросов:

 - зачем это нужно?
 - что это решит?
 - можно ли обойтись без этого?
 - какие есть аналоги?
 - какая есть экспертиза?

И если на весах аргументов и фактов "что-то" новое проиграет, то следует смело проезжать мимо.

Итак, как уже можно догадаться, в Go, как и во многих других ЯП существует, по крайней мере, 2 больших лагеря:
 - монолитчики
 - микросервисники

На практике их куда больше и очень, очень часто понятия размываются, но по краям остаются моно и микро. Часто можно
встретить НЕ монолиты и НЕ микросервисы, а просто сервисы, ну или крайность, размазанные микросервисы, тн наносервисы.
Всё это происходит стихийно, и как правило, за бизнесом нужен глаз да глаз.

В чём же разница? Если грубо, то один микросервис может отвечать за один домен, например myowesomeecommerce.com/orders
Тогда как монолит владеет группой доменов, ну или поддоменов.

Немного о плюсах и минусах подходов.
В монолитном приложении достаточно удобно тестировать взаимодействие между модулями внутри, тк они находятся в рамках
одной кодовой базы, тогда как тн интеграционное тестирование микросервисов становится почти что кошмаром для некоторых
команд. Почему кошмаром? Всё из-за функционала, распределённого в ряде доменов: когда функционал далеко, то его сложнее
достать или определить его поведение заготовленным сценарием (моками). В монолите этого нет, всё рядом и достать легче.

Далее, в монолите куда больше кода и зачастую контрибютеров, так что согласовать изменения становится сложнее чем в
микросервисах. Тебе приходится учитывать больше взаимодействия внутри, тк компоненты ближе и больше вероятности их связи.
Надеюсь вы, как и мы, используете статически типизированный язык или статический анализ, это слегка упростит жизнь, хотя
бы её часть. Отличным выбором станет Go =)

Как бы микросервисы не пытались развязаться друг от друга, у них есть кое-что, что связывает их куда сильнее, чем просто
неявные связи в монолите, а именно, общие данные или сквозные данные. Микросервисам приходится синхронизироваться, и это
всегда проблема. Обращаться напрямую к другим сервисам с теми же данными или асинхронно, получая сообщения? Консистентность
и согласованность данных из разных микросервисов, а эти данные так и норовят быть размазаны. Поэтому надо стараться держать
нужное рядом, но не превратиться в монолит. Есть ещё страшная вещь - распределённый монолит, это как раз, когда по сервисам
раскиданы общие данные и собирать их сущий ад.

Развёртывание или деплой, ну тут всё ясно, чем ты меньше - тем проще развернуться. То же самое касается массовых операций,
типа тестирования, проверок линтерами, переключения feature-toggles, и тд. Управлять проще чем-то маленьким.

Но есть сфера, в которой просто приходится становиться меньше, а именно горизонтальное масштабирование. Предположим что
есть интерфейс, который является фасадом для приёма заказов. Нам нужна хорошая пропускная способность и возможность
добавлять ресурсов для работы, если это потребуется. Поэтому мы выделяем эту сущность в некий order-facade, даём ему
нужный функционал для приёма заказов, причём так, чтобы на пути создания заказа было как можно меньше препятствий. Всё,
готово, можем запускать! Ресурс - это количество экземпляров этого order-facade чтобы мы не упёрлись в очередь клиентов,
они же могут просто не дождаться своей очереди и уйти. Дальше тоже могут возникнуть сложности в организации доставки
этих данных для приготовления заказов от клиентов и не забыть отправить их в ожидание. И тут очевидны плюсы микросервиса:
он маленький, легко копируемый, просто нужно согласовать работу в кластере (не самая лёгкая из задач, но оно того стоит).
С монолитом так легко и просто не выйдет. Самое сложное в масштабировании монолита, это организация взаимодействия в
кластере, это всегда проблема. У монолита внутри множество связей и завязок и с этим приходится жить.

Также стоить помнить, что нужно группировать функционал и не размазывать его по модулям/сервисам. Стараться держать
нужное вместе. Мы не хотим прийти к распределённому монолиту, как это часто бывает на рефакторинге/распиле модулей
монолитных приложений у некоторых команд.

Немного про инструменты, используемые вместе с Go.

Как правило, это СУБД, кеши, брокеры очередей и тд. При выборе инструмента стоить внимательно ознакомиться с тем, какие
задачи будут решаться и подходит ли данный инструмент для использования. Например, для mvp или proof of concept какого-то
функционала, необязательно затягивать целый кластер redis к себе на проект, достаточно будет воспользоваться инструментами,
которые Go и так предоставляет, а именно создать структуру с мьютексом и мапой. Это и будет наш кеш на первое время. Более
того, часто бывает так, что этот кеш остаётся на первом уровне, тогда как мы понимаем что нам нужен, например, redis или
memcached и начинаем использовать их на следующем уровне lN. Стоить помнить об инвалидации каждого уровня и согласованности
данных в кластере.

По поводу реляционных СУБД, тут тоже стоить понимать и предполагать, какие нагрузки будут у сервиса, как много сущностей
будут участвовать в реляции, ну и, конечно, не плодить связи, если ваша система требует производительности. Инструменты
для работы с реляционными СУБД существуют в большом количестве, но если у вас есть сложные агрегирующие запросы или любые
другие сложные запросы, я не рекомендую использовать что-то, что работает шаблонно, по типу ORM или кодогенераторы запросов.
Вы точно не хотите вендорлок на зоопарке библиотек, особенно, если в этих библиотеках есть баги, которые так и не были
решены. В любом случае при использовании той или иной библиотеки, озаботьтесь изучением проблем этой библиотеки и
сравните с аналогами.

К помощи таких инструментов как брокеры сообщений, скорее всего, вы придёте не сразу, но всегда надо помнить, что существует
два разных подхода в доставке сообщений, выделим RabbitMQ и Apache Kafka. Если кратко, то в RabbitMQ много логики на
стороне брокера и мало на стороне потребителя. У Kafka наоборот, мало логики на стороне брокера, но много у потребителя.
Детальнее рассмотреть различные подходы в доставке сообщений можно по ссылке и другой информации в сети.

- https://habr.com/ru/companies/innotech/articles/698838/

Это был краткий экскурс в абстракции работы сервисов не только Go.

Теперь можно заглянуть поглубже. Как уже было сказано, стараться избегать "чего-то", не пройдя опросник выше и не взвесив
все за и против. Это нужно для:

 - удобства поддержки
 - масштабирования
 - тестирования
 - оптимизации
 - добавления нового функционала
 - изучения кодовой базы и тд

Теперь немного про тонкости самого Go как инструмента.

Абстракции.
Их нужно использовать грамотно. Прежде всего, абстракции помогают при тестировании кода, чуть реже, когда у вас получается
хорошее приложение, то вы можете заменять инструменты или компоненты, используя абстрактный интерфейс. Это бывает очень
полезно. Но, любая абстракция - это затрата. Не стоит просто так лепить интерфейс для абсолютно чего угодно или увидев
новый паттерн, добавить что-то новое и интересное. Прежде всего это замедлит time to market или delivery нового функционала.
Причём не только первоначально, но и в последующем. Будьте внимательны, не пропускайте случайную абстракцию, проводя код-ревью.

Реализацию абстракций в Go или инверсия зависимости.

Чуть-чуть про инверсию как концепт (один из принципов SOLID)

- https://habr.com/ru/articles/706416/

Существует подход с интерфейсами в месте использования и тн "пакетные интерфейсы". Я рекомендую использовать первый подход,
тк он будет способствовать избавлению от ненужного кода и с тз Go будет более правильным: код будет большее duck typed.

Про утиную типизацию
- https://www.fullstory.com/blog/is-go-duck-typed/

Например, мы пишем крон-сервис, который должен доставать данные из БД и что-то делать с ними или на их основе. Определим
интерфейс orderer в этом же пакете с кроном. Определим нужные методы у orderer, например
ListOrders(context.Context, *dto.ListOrderFilter) ([]*model.Order, error). Далее напишем или сгенерируем mock для этого
интерфейса в этом же пакете и, в целом, всё! Нам больше ничего не надо, мы можем смело использовать mock для составления
сценариев и тестирования нашего крона с множеством вариантов ответа от orderer. В конструктор крона мы отправим тот
самый репозиторий, у которого, помимо всего прочего, есть данный метод. Даже больше, если мы решим использовать
кеширующий репозиторий-обёртку или какой-то сторонний клиент, если наши заказы "уедут в другой сервис", мы всегда знаем
данный интерфейс и можем использовать его. Просто подменим реализацию в конструкторе и всё, это очень удобно.

По большей части, в Go принято использовать микросервисный подход. Из этого следует, что функционала в сервисе будет не
так много и он будет достаточно связан. Из этого я бы рекомендовал использовать "сквозные DTO" или "сквозные модели".
Дело тут вот в чём: пакетные дто могут быть полезны, но только если мы используем конкретную реализацию. Если же мы работаем
с абстракцией, то архитектурно неправильно использовать конкретные пакетные DTO/модели. Поэтому стоит озаботиться пакетом
и подпакетами (если это необходимо) для них.

Репозитории и хранилища данных.
Я стараюсь придерживаться подхода стандартизации работы с запросами и командами на изменение ресурса: любое хранилище
данных - это репозиторий. Да, безусловно, реализации бывают разными, реляционные бд, кеши, удалённые сервисы, даже
некоторые брокеры сообщений могут быть хранилищами данных, например те, которые хранят лог отправленных сообщений. Да,
все они работают по-разному, разные варианты подключения и передачи данных, разная скорость, но всё это репозитории.
Мы можем запросить или обновить данные в них. Поэтому стоит придерживаться единого подхода к запросам и командам в них,
для удобства их подмены или оборачивания (пример с кеширующим репозиторием). При всём при этом я рекомендую разделять их
на clients, repos и тд.

Internal.
Такой вот инструмент Go, позволяющий инкапсулировать некоторый функционал целого Go модуля, чтобы при его импорте, этот
функционал не был доступен. Это один из самых мощных инструментов программирования - инкапсуляция, но на уровне целого модуля.

Pkg.
Этот пакет используется как раз наоборот для того что хочется "отдать наружу", а через него уже может быть осуществлено
взаимодействие с go модулем. Не советую класть pkg в internal, тк учёные до сих пор спорят о природе этого явления.

Работа с сущностями.
В проектах как с ORM, так и без них часто возникают сущности, модели или dto или даже все эти элементы частично или сразу.
Это нормально. Существует несколько признаков того что ваша сущность DTO или модель:

 - DTO: не имеет инкапсуляции и поведения, открыта для юзкейсов
 - Модель: имеет инкапсуляцию, поведение и даже состояние. Существует также варианты с иммутабельным (неизменяемым) состоянием

Что использовать - решать уже вам самому, разница есть, она очевидна, но свои преимущества есть в обоих подходах. Например,
ДТО может быть переиспользована во множестве сценариев или функциях, тогда как модельки плодятся от типа к типу достаточно
быстно. За то модельки лучше управляют состоянием, но на их содержание уходит больше времени, тогда как с ДТО может
возникнуть больше проблем, при "неучтёнке" юзкейса, решать, конечно, вам.

Нагрузка приложений написанных на Go, да и не только на Go, породила паттерн-практику добавлять для нагруженных работой
элементов под названием Graceful shutdown. В целом это значит, что наше приложение не исчезает в пространстве и времени
мгновенно при его остановке, ротации подов в оркестре или даже фатальной ошибке приложения. Суть в том, чтобы перестать
принимать новые задания от клиентов и закончить обслуживание тех, кто успел раньше. Это отличная практика, позволяющая не
потерять данные, легко "переподниматься" и не "обрубать концы" в микросервисном обмене.

 - https://blog.ildarkarymov.ru/posts/graceful-shutdown/
 - https://www.youtube.com/watch?v=ASiF-AH7GFc
 - https://habr.com/ru/companies/timeweb/articles/589167/

Думаю, что для начала, этого краткого экскурса в дизайн приложений на Go будет вполне достаточно
